#!/usr/bin/env python3
"""
Markdown 文档生成器
从查询结果生成规范的 Markdown 文档并保存到用户目录
"""

import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List


def get_default_output_dir() -> Path:
    """获取默认文档输出目录（用户主目录）

    Returns:
        Windows: C:\\Users\\{username}\\DTS-Docs\\
        Mac/Linux: ~/DTS-Docs/
    """
    home = Path.home()
    output_dir = home / 'DTS-Docs'

    # 如果设置了环境变量，优先使用
    env_dir = os.environ.get('DTS_DOCS_DIR')
    if env_dir:
        output_dir = Path(env_dir)

    # 自动创建目录
    output_dir.mkdir(parents=True, exist_ok=True)

    return output_dir


def generate_markdown(result: dict, output_dir: Path = None) -> str:
    """生成 Markdown 文档并保存到用户目录

    Args:
        result: query_api 返回的结果字典
        output_dir: 输出目录，默认使用用户主目录下的 DTS-Docs

    Returns:
        生成的文档文件路径
    """
    if not result.get('success'):
        print(f"[SKIP] Query failed: {result.get('error')}")
        return None

    if output_dir is None:
        output_dir = get_default_output_dir()

    data = result['data']
    class_name = data.get('class_name', 'Unknown')
    source_url = data.get('source_url', 'Unknown')

    # 生成文件名
    filename = f"{class_name}.md"
    file_path = output_dir / filename

    # 生成 Markdown 内容
    markdown_content = _generate_content(data, source_url)

    # 保存文件（使用 UTF-8 编码）
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(markdown_content)

    return str(file_path)


def _generate_content(data: dict, source_url: str) -> str:
    """生成 Markdown 内容

    Args:
        data: 解析后的 API 数据
        source_url: 文档来源 URL

    Returns:
        Markdown 文本
    """
    lines = [
        "---",
        "# Auto-generated by dts-docs-query",
        f"# Class: {data['class_name']}",
        f"# Generated at: {datetime.now().isoformat()}",
        f"# Source: {source_url}",
        "---",
        "",
        f"# {data['class_name']}",
        "",
        f"**描述**: {data['description']}",
        "",
        f"**包含方法**: {len(data['methods'])} 个",
        "",
        "## 方法列表",
        ""
    ]

    # 生成所有方法的详细信息
    for method in data['methods']:
        lines.append(f"### {method['name']}")
        lines.append("")
        lines.append(f"**签名**: `{method['signature']}`")
        lines.append("")
        lines.append(f"**描述**: {method['description']}")
        lines.append("")

        # 参数
        if method['parameters']:
            lines.append("**参数**:")
            for param in method['parameters']:
                lines.append(f"- `{param['name']}` ({param['type']}): {param['description']}")
            lines.append("")

        # 返回值
        if method['returns']:
            lines.append(f"**返回值**: {method['returns']}")
            lines.append("")

        # 示例代码
        if method['examples']:
            lines.append("**示例**:")
            for ex in method['examples']:
                lines.append("```javascript")
                lines.append(ex)
                lines.append("```")
            lines.append("")

        lines.append("---")
        lines.append("")

    return '\n'.join(lines)


def generate_method_markdown(method: dict, class_name: str, output_dir: Path = None) -> str:
    """生成单个方法的 Markdown 文档

    Args:
        method: 单个方法的数据
        class_name: 类名
        output_dir: 输出目录

    Returns:
        生成的文档文件路径
    """
    if output_dir is None:
        output_dir = get_default_output_dir()

    # 生成文件名：ClassName-methodName.md
    filename = f"{class_name}-{method['name']}.md"
    file_path = output_dir / filename

    lines = [
        "---",
        "# Auto-generated by dts-docs-query",
        f"# Method: {class_name}.{method['name']}",
        f"# Generated at: {datetime.now().isoformat()}",
        "---",
        "",
        f"# {class_name}.{method['name']}",
        "",
        f"**签名**: `{method['signature']}`",
        "",
        f"**描述**: {method['description']}",
        ""
    ]

    # 参数
    if method['parameters']:
        lines.append("**参数**:")
        for param in method['parameters']:
            lines.append(f"- `{param['name']}` ({param['type']}): {param['description']}")
        lines.append("")

    # 返回值
    if method['returns']:
        lines.append(f"**返回值**: {method['returns']}")
        lines.append("")

    # 示例代码
    if method['examples']:
        lines.append("**示例**:")
        for ex in method['examples']:
            lines.append("```javascript")
            lines.append(ex)
            lines.append("```")

    markdown_content = '\n'.join(lines)

    # 保存文件
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(markdown_content)

    return str(file_path)


def generate_all_markdowns(data: dict) -> dict:
    """生成所有格式的 Markdown（用于缓存）

    Args:
        data: 解析后的 API 数据

    Returns:
        包含 full, compact, methods 的字典
    """
    return {
        'full': _generate_full_markdown(data),
        'compact': _generate_compact_markdown(data),
        'methods': {
            method['name']: _generate_method_markdown(method, data['class_name'])
            for method in data['methods']
        }
    }


def _generate_full_markdown(data: dict) -> str:
    """生成完整格式（所有方法详情）"""
    lines = [
        f"# {data['class_name']}\n",
        f"**描述**: {data['description']}\n",
        f"**包含方法**: {len(data['methods'])} 个\n",
        "## 方法详情\n"
    ]

    for method in data['methods']:
        lines.append(_generate_method_markdown(method, data['class_name']))
        lines.append("\n---\n")

    return '\n'.join(lines)


def _generate_compact_markdown(data: dict) -> str:
    """生成简洁格式（方法列表概览）"""
    lines = [
        f"# {data['class_name']}\n",
        f"**描述**: {data['description']}\n",
        f"**包含方法**: {len(data['methods'])} 个\n",
        "## 方法列表\n"
    ]

    for method in data['methods'][:10]:
        desc = method['description'][:80] + '...' if len(method['description']) > 80 else method['description']
        lines.append(f"- **{method['signature']}**: {desc}")

    if len(data['methods']) > 10:
        lines.append(f"\n... 还有 {len(data['methods']) - 10} 个方法")

    return '\n'.join(lines)


def _generate_method_markdown(method: dict, class_name: str) -> str:
    """生成单个方法的 Markdown"""
    lines = [
        f"### {method['name']}\n",
        f"**签名**: `{method['signature']}`\n",
        f"**描述**: {method['description']}\n"
    ]

    if method['parameters']:
        lines.append("**参数**:")
        for param in method['parameters']:
            lines.append(f"- `{param['name']}` ({param['type']}): {param['description']}")
        lines.append("")

    if method['returns']:
        lines.append(f"**返回值**: {method['returns']}")
        lines.append("")

    if method['examples']:
        lines.append("**示例**:")
        for ex in method['examples']:
            lines.append("```javascript")
            lines.append(ex)
            lines.append("```")
        lines.append("")

    return '\n'.join(lines)


if __name__ == '__main__':
    import sys

    if len(sys.argv) < 2:
        print("Usage: python doc_generator.py <json_file> [output_dir]")
        print("\nExample:")
        print("  python doc_generator.py data/cache/Marker.json")
        print("  python doc_generator.py data/cache/Marker.json C:\\MyDocs")
        sys.exit(1)

    json_file = sys.argv[1]
    output_dir = Path(sys.argv[2]) if len(sys.argv) > 2 else None

    # 读取 JSON 文件
    import json
    with open(json_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    # 构造 result 字典
    result = {
        'success': True,
        'data': data
    }

    # 生成文档
    doc_path = generate_markdown(result, output_dir)
    print(f"Documentation saved: {doc_path}")
